{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar is = require('./is.js');\n\nvar token = require('./token.js');\n\nvar bl = require('./bl.js');\n\nvar common = require('./common.js');\n\nvar jump = require('./jump.js');\n\nvar byteUtils = require('./byte-utils.js');\n\nvar _0uint = require('./0uint.js');\n\nvar _1negint = require('./1negint.js');\n\nvar _2bytes = require('./2bytes.js');\n\nvar _3string = require('./3string.js');\n\nvar _4array = require('./4array.js');\n\nvar _5map = require('./5map.js');\n\nvar _6tag = require('./6tag.js');\n\nvar _7float = require('./7float.js');\n\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nconst cborEncoders = [];\ncborEncoders[token.Type.uint.major] = _0uint.encodeUint;\ncborEncoders[token.Type.negint.major] = _1negint.encodeNegint;\ncborEncoders[token.Type.bytes.major] = _2bytes.encodeBytes;\ncborEncoders[token.Type.string.major] = _3string.encodeString;\ncborEncoders[token.Type.array.major] = _4array.encodeArray;\ncborEncoders[token.Type.map.major] = _5map.encodeMap;\ncborEncoders[token.Type.tag.major] = _6tag.encodeTag;\ncborEncoders[token.Type.float.major] = _7float.encodeFloat;\nconst buf = new bl.Bl();\n\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n\n  includes(obj) {\n    let p = this;\n\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n\n    return false;\n  }\n\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${common.encodeErrPrefix} object contains circular references`);\n    }\n\n    return new Ref(obj, stack);\n  }\n\n}\n\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new token.Token(token.Type.break)];\n      }\n\n      return simpleTokens.emptyArray;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.array, obj.length), entries, new token.Token(token.Type.break)];\n    }\n\n    return [new token.Token(token.Type.array, obj.length), entries];\n  },\n\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new token.Token(token.Type.break)];\n      }\n\n      return simpleTokens.emptyMap;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n\n    sortMapEntries(entries, options);\n\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.map, length), entries, new token.Token(token.Type.break)];\n    }\n\n    return [new token.Token(token.Type.map, length), entries];\n  }\n\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\n\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\n\nfunction objectToTokens(obj) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let refStack = arguments.length > 2 ? arguments[2] : undefined;\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n\n  const typeEncoder = typeEncoders[typ];\n\n  if (!typeEncoder) {\n    throw new Error(`${common.encodeErrPrefix} unsupported type: ${typ}`);\n  }\n\n  return typeEncoder(obj, typ, options, refStack);\n}\n\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\n\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n\n  return tcmp;\n}\n\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\n\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n\n    if (quickBytes) {\n      return quickBytes;\n    }\n\n    const encoder = encoders[tokens.type.major];\n\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.objectToTokens = objectToTokens;","map":{"version":3,"sources":["/Users/intvirtue/Last-final/node_modules/cborg/cjs/lib/encode.js"],"names":["Object","defineProperty","exports","value","is","require","token","bl","common","jump","byteUtils","_0uint","_1negint","_2bytes","_3string","_4array","_5map","_6tag","_7float","defaultEncodeOptions","float64","mapSorter","quickEncodeToken","cborEncoders","Type","uint","major","encodeUint","negint","encodeNegint","bytes","encodeBytes","string","encodeString","array","encodeArray","map","encodeMap","tag","encodeTag","float","encodeFloat","buf","Bl","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","encodeErrPrefix","simpleTokens","null","Token","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","encoders","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","asU8A","toBytes","encode","assign"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar is = require('./is.js');\nvar token = require('./token.js');\nvar bl = require('./bl.js');\nvar common = require('./common.js');\nvar jump = require('./jump.js');\nvar byteUtils = require('./byte-utils.js');\nvar _0uint = require('./0uint.js');\nvar _1negint = require('./1negint.js');\nvar _2bytes = require('./2bytes.js');\nvar _3string = require('./3string.js');\nvar _4array = require('./4array.js');\nvar _5map = require('./5map.js');\nvar _6tag = require('./6tag.js');\nvar _7float = require('./7float.js');\n\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nconst cborEncoders = [];\ncborEncoders[token.Type.uint.major] = _0uint.encodeUint;\ncborEncoders[token.Type.negint.major] = _1negint.encodeNegint;\ncborEncoders[token.Type.bytes.major] = _2bytes.encodeBytes;\ncborEncoders[token.Type.string.major] = _3string.encodeString;\ncborEncoders[token.Type.array.major] = _4array.encodeArray;\ncborEncoders[token.Type.map.major] = _5map.encodeMap;\ncborEncoders[token.Type.tag.major] = _6tag.encodeTag;\ncborEncoders[token.Type.float.major] = _7float.encodeFloat;\nconst buf = new bl.Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ common.encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.array, obj.length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.map, length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ common.encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.objectToTokens = objectToTokens;\n"]},"metadata":{},"sourceType":"script"}