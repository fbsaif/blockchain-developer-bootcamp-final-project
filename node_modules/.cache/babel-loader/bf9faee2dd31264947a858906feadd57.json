{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar varint = require('./varint.js');\n\nvar digest = require('./hashes/digest.js');\n\nvar base58 = require('./bases/base58.js');\n\nvar base32 = require('./bases/base32.js');\n\nvar bytes = require('./bytes.js');\n\nclass CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return this;\n        }\n\n      default:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n\n          return CID.createV0(multihash);\n        }\n    }\n  }\n\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest: digest$1\n          } = this.multihash;\n          const multihash = digest.create(code, digest$1);\n          return CID.createV1(this.code, multihash);\n        }\n\n      case 1:\n        {\n          return this;\n        }\n\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);\n  }\n\n  toString(base) {\n    const {\n      bytes,\n      version,\n      _baseCache\n    } = this;\n\n    switch (version) {\n      case 0:\n        return toStringV0(bytes, _baseCache, base || base58.base58btc.encoder);\n\n      default:\n        return toStringV1(bytes, _baseCache, base || base32.base32.encoder);\n    }\n  }\n\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest$1 = digest.decode(multihash);\n      return CID.create(version, code, digest$1);\n    } else {\n      return null;\n    }\n  }\n\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n\n    return cid;\n  }\n\n  static decodeFirst(bytes$1) {\n    const specs = CID.inspectBytes(bytes$1);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));\n\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);\n    return [cid, bytes$1.subarray(specs.size)];\n  }\n\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n\n    let version = next();\n    let codec = DAG_PB_CODE;\n\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n\n    cid._baseCache.set(prefix, source);\n\n    return cid;\n  }\n\n}\n\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    case 'Q':\n      {\n        const decoder = base || base58.base58btc;\n        return [base58.base58btc.prefix, decoder.decode(`${base58.base58btc.prefix}${source}`)];\n      }\n\n    case base58.base58btc.prefix:\n      {\n        const decoder = base || base58.base58btc;\n        return [base58.base58btc.prefix, decoder.decode(source)];\n      }\n\n    case base32.base32.prefix:\n      {\n        const decoder = base || base32.base32;\n        return [base32.base32.prefix, decoder.decode(source)];\n      }\n\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n\n        return [source[0], base.decode(source)];\n      }\n  }\n};\n\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n\n  if (prefix !== base58.base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\n\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\n\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\n\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;\nexports.CID = CID;","map":{"version":3,"sources":["/Users/intvirtue/Last-final/node_modules/multiformats/cjs/src/cid.js"],"names":["Object","defineProperty","exports","value","varint","require","digest","base58","base32","bytes","CID","constructor","version","code","multihash","byteOffset","byteLength","asCID","_baseCache","Map","defineProperties","hidden","readonly","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest$1","create","createV1","equals","other","toString","base","toStringV0","base58btc","encoder","toStringV1","toJSON","hash","Symbol","toStringTag","for","isCID","deprecate","IS_CID_DEPRECATION","cidSymbol","toBaseEncodedString","codec","buffer","multibaseName","prefix","encodeCID","decode","cid","remainder","decodeFirst","length","bytes$1","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","coerce","subarray","digestBytes","digestSize","Digest","multihashCode","initialBytes","offset","next","i","RangeError","parse","source","parseCIDtoBytes","set","decoder","cache","name","get","encode","slice","codeOffset","encodingLength","hashOffset","Uint8Array","encodeTo","writable","configurable","enumerable","range","message","test","console","warn"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint = require('./varint.js');\nvar digest = require('./hashes/digest.js');\nvar base58 = require('./bases/base58.js');\nvar base32 = require('./bases/base32.js');\nvar bytes = require('./bytes.js');\n\nclass CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest: digest$1} = this.multihash;\n        const multihash = digest.create(code, digest$1);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58.base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest$1 = digest.decode(multihash);\n      return CID.create(version, code, digest$1);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes$1) {\n    const specs = CID.inspectBytes(bytes$1);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);\n    return [\n      cid,\n      bytes$1.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58.base58btc;\n      return [\n        base58.base58btc.prefix,\n        decoder.decode(`${ base58.base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58.base58btc.prefix: {\n      const decoder = base || base58.base58btc;\n      return [\n        base58.base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.base32.prefix: {\n      const decoder = base || base32.base32;\n      return [\n        base32.base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58.base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;\n\nexports.CID = CID;\n"]},"metadata":{},"sourceType":"script"}